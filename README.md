# Buscaminas
# Proyecto de programaci√≥n sobre el desarrollo de un Buscaminas 

---
#### Integrantes del grupo

* Juan Esteban Arias Lozano
C.C 1011095584
juariaslo@unal.edu.co
* Miguel Angel Moreno Alvarez
C.C 1072423634
migmorenoal@unal.edu.co
* Santiago Aldemar Aguilar Riveros
C.C 1031651244
saaguilar@unal.edu.co
---
# Definici√≥n de la Alternativa


## üìå Objetivo
El proyecto tiene como objetivo el desarrollo de un Buscaminas, este debe consistir de una interfaz simple y facil de entender, debe implemenatar a si mismo una l√≥gica de juego correcta y  desarrollar una versi√≥n completamente funcional.


## üìå Objetivo del avance
El avance del proyecto tiene como objetivo principal asegurar un desarrollo estructurado y eficiente, comenzando con una planeaci√≥n detallada que establece los pasos necesarios para alcanzar la meta propuesta. Actualmente, se ha trabajado en la creaci√≥n de la interfaz y la implementaci√≥n de las funciones b√°sicas, priorizando un dise√±o intuitivo y funcional que facilite la experiencia del usuario. Durante el desarrollo, se han identificado diversos obst√°culos y dificultades, tales como la integraci√≥n de ciertos componentes, los cuales requieren un enfoque m√°s profundo para garantizar la funcionalidad del sistema.

---

<table cellspacing="1" bgcolor="">
	<tr bgcolor="#252582">
		<th><b>Buscaminas: ¬øQu√© es un Buscaminas?</b></th>
	</tr>
	<tr bgcolor="#e4e4ed">
		<td style="color:#141414"> 
      Buscaminas es un g√©nero de videojuegos de l√≥gica. El videojuego presenta una cuadr√≠cula de casillas en las que se puede hacer clic, donde hay ¬´minas¬ª ocultas esparcidas por todo el tablero. <br>
      El objetivo es limpiar el tablero sin detonar ninguna mina, con la ayuda de pistas sobre el n√∫mero de minas vecinas en las casillas circundantes..<br><br>
      <p align="center">
        <img src="https://www.ludoteka.com/img/juegos/buscaminas3.png" height="180">
      </p>
    </td>
  </tr>
</table>

## Diagrama preliminar

Para describir el proceso y facilitar el desarrollo del algoritmo se opt√≥ por realizar un diagra de flujo que resume el funcionamiento b√°sico del juego, desde el inicio, determinar si se gana o pierde, o el resultado de una casilla vac√≠a. 

<details><summary>Diagrama de flujo </summary><p>

```mermaid
flowchart TD
    n1["Leer Rango"] --> n2["Leer Numero de minas"]
    n2 --> A["Generar Matriz de tablero"]
    A --> B("Colocar minas aleatoriamente")
    B --> n3["Descubir casilla"]
    n3 --> C{"¬øEs una mina?"}
    C -- No --> n4["Mostrar numero de minas vecinas"]
    C -- Si --> n5["Perdiste"]
    n6["¬øHay casillas libres?"] -- No --> n10["Ganaste"]
    n11(["Inicio"]) --> n1
    n10 --> n12["¬øVolver a jugar?"]
    n5 --> n12
    n6 --> n3
    n4 --> n6
    n12 -- Si --> n1
    n12 -- No --> n13(["Fin"])
    n1@{ shape: lean-r}
    n2@{ shape: lean-r}

```
</p></details><br>


## üìå 2. Mec√°nica de Juego

El Buscaminas es un juego de l√≥gica en el que debes descubrir todas las casillas vac√≠as de un tablero sin detonar ninguna mina.


<details><summary>Tablero y casillas: Se presenta una cuadr√≠cula con casillas ocultas, algunas de las cuales contienen minas.</summary><p>

* Creamos el tablero con una matriz, con la posibilidad de modificar el rango del tablero

  ![image](https://github.com/user-attachments/assets/efe6fb7e-a773-489a-bda7-a7cdb0e43129)


* A√±adimos Un random para minas aleatorias en la matriz


</p></details><br>
<details><summary>Clic inicial:</summary><p>

‚Äî Para ejecuci√≥n en consola se ten√≠an dos opciones

  * Inciar en una posici√≥n y desplazarnos por el tablero
  * Coordenadas para ubicar las posiciones

![image](https://github.com/user-attachments/assets/6cfb66be-fbab-4bdf-9f7f-1fe65cded9c0)

</p></details><br>

<details><summary>Descubrir casilla: Al hacer clic en una casilla, puede ocurrir una de dos cosas:</summary><p>

* ###  Casilla vac√≠a, indica cu√°ntas minas hay en las casillas adyacentes.

![Captura de pantalla 2025-01-29 103402](https://github.com/user-attachments/assets/ffa89a63-5e62-4d47-aa5c-a035ee9f7f3e)

* ###  Mina, pierdes la partida.

![image](https://github.com/user-attachments/assets/4aecdb59-3e90-4d8f-9a46-704854a35dad)

</p></details><br>

‚ñ∂ Estrategia y l√≥gica: Usando los n√∫meros revelados, debes deducir d√≥nde est√°n las minas y marcarlas con banderas.

‚ñ∂ Victoria: Ganas si descubres todas las casillas sin minas.

## üìå 3. Posibles Desaf√≠os

En la planeaci√≥n y la realizaci√≥n parcial del proyecto, fueron hallados y pensados algunos obstaculos y desafios, que podr√≠an llegar a requerir m√°s esfuerzo o atenci√≥n en el futuro, tales como:
* L√≥gica para la expansi√≥n de casillas vac√≠as al hacer clic.
* Gesti√≥n de eventos y actualizaciones gr√°ficas en la interfaz.
* Validaci√≥n de condiciones de victoria y derrota
* Programacion del Temporizador
* Conteo de puntaje

## ¬øComo se abordo la solucion de crear un buscaminas en python?
Partimos desde el hecho de que el funcionamiento de un buscaminas se relaciona con las matrices en python; para jugar un buscaminas es necesario tener una tablero de bloques que forman filas y columnas, ah√≠ es donde se encuentran las minas. 

<p align="center">
  <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR2uE_vmb6-A35XfltEbnAQyrvBcCbxBP3Y4A&amp;s" height="180">
  <img src="https://github.com/user-attachments/assets/6cfb66be-fbab-4bdf-9f7f-1fe65cded9c0" alt="image" height="180">
  <!-- <img src="https://play-lh.googleusercontent.com/eX5S3Tv3eSO1aWDMQ7MGRO1AaZM-mF0EvRbNsUM887kJVHj0aKv4GnDNj6ds_qvhpak" height="180"> -->
</p>


La base del codigo consiste en crear una matriz base a las minas asignamos el valor 1 y las casillas vacias 0

```
    def generar_tablero(tamano, minas):
    # Se crea una matriz de ceros los cuales son las posiciones seguras 
    matriz = [[0] * tamano for m in range(tamano)]

    # este if es en caso de que las minas sean mayores que el tama√±o de la matriz 
    if minas > tamano * tamano:
        return "Error: La cantidad de minas es mayor que el tama√±o del tablero."

    # Con esta linea de codigo se generan aleatoriamente las posiciones de los 1 
    indices = np.random.choice(tamano * tamano, minas, replace=False)

    # Colocar las minas en la matriz
    for p in indices:
        fila = p // tamano  # Determinar la fila
        columna = p % tamano  # Determinar la columna
        matriz[fila][columna] = 1

    return matriz  # Devolvemos la matriz con las minas
```

Para la ubicaci√≥n de minas fue necesario importar una funcion de la biblioteca `NumPy`

```
import numpy as np

# Obtener √≠ndices aleatorios para colocar las minas
    indices = np.random.choice(tamano * tamano, minas, replace=False)
```

_`replace=False` indica que no se deben seleccionar √≠ndices repetidos. Esto Esto garantiza que solo puede existir una mina por celda._


Esta funcion imprime la interfaz del juego  para que  se vea acorde a un sistema de coordenadas. 

```
    def tablerito(columnas, matriz):
      print("     ", end="") 
     for i in range(65, 65 + columnas):  # Cambi√© 73 por 65 + columnas para que se ajuste al tama√±o
        print(chr(i), end=" ")
    print()

    for i in range(1, columnas + 1):
        if i > 9:
            print(i, end="   ")
        else:
            print(i, end="    ")
        for j in range(columnas):
            if matriz[i - 1][j] == 1:
                print("1", end=" ")  # Representa una mina
            else:
                print("‚ñ°", end=" ")  # Representa un espacio vac√≠o
        print()
    return tablerito
```

Para contar las minas adyacentes usamos la siguiente funci√≥n

```
def contar_minas_alrededor(matriz, fila, columna):
    #Cuenta el n√∫mero de minas alrededor de una posici√≥n dada.
    filas = len(matriz)
    columnas = len(matriz[0])
    minas_cerca = 0

    # Recorrer las posiciones vecinas
    for i in range(max(0, fila - 1), min(filas, fila + 2)):
        for j in range(max(0, columna - 1), min(columnas, columna + 2)):
            if (i, j) != (fila, columna) and matriz[i][j] == 1:
                minas_cerca += 1
    return minas_cerca
```
Para hacer las actualizaciones del tablero se utiliza la siguiente funcion basada en la de la interafz del juego:

```
    def mostrar_tablero_actualizado(matriz, fila, columna):
# Tiene la misma estructura de la funcion tablerito, es para ordenar la matriz 
    filas = len(matriz)
    columnas = len(matriz[0])
    print("\n--- Tablero actualizado ---")
    print("     ", end="")
    for i in range(65, 65 + columnas):  # Cambi√© 73 por 65 + columnas para que se ajuste al tama√±o
        print(chr(i), end=" ")
    print()
	 for x in range(filas):
	        if x >= 9:
	            print(x + 1, end="   ")
	        else:
	            print(x + 1 , end="    ")
	        for y in range(columnas):
	            if x == fila and y == columna:
	                minas_cerca = contar_minas_alrededor(matriz, fila, columna)
	                print(minas_cerca, end=" ")
	            else:
	                print("‚ñ°", end=" ")
	        print()

```

Posteriormente se utiliza una funci√≥n que evalua dato ingresado, verificando si es un digito o no:

```
	def es_numero(valor):
	        for caracter in valor:
	            if caracter < '0' or caracter > '9':
	             return False
	        return True
```

Para hacer el filtro de ingreso de datos y estar seguros de que las coordenadas ingresadas son correctas se usa esta funcion:

```
def verificar_coordenada(matriz):
    filas = len(matriz)
    columnas = len(matriz[0])

    while True:
        # Pedir la coordenada en un solo input
        entrada = input("Ingrese la coordenada (entre 1-" + str(filas) + "y A-" + chr(64 + columnas) + "): ").upper()

        # Separar la entrada en fila y columna
        partes = entrada.split()
        if len(partes) != 2:
            print("Formato incorrecto. Debe ser 'fila columna'. Intenta nuevamente.")
            continue

        fila_txt, columna_txt = partes

        # Verificar la fila
        if es_numero(fila_txt) == False:
            print("Fila no es un n√∫mero v√°lido, intenta nuevamente.")
            continue

        fila = int(fila_txt) - 1
        if fila < 0 or fila >= filas:
            print("Fila fuera de rango, intenta nuevamente.")
            continue

        # Verificar la columna
        if len(columna_txt) != 1 or not ('A' <= columna_txt <= chr(64 + columnas)):
            print("Columna fuera de rango, intenta nuevamente.")
            continue

        columna = ord(columna_txt) - 65  # Convertir la letra a √≠ndice de columna

        # Verificar si hay una mina en la posici√≥n
        if matriz[fila][columna] == 1:
            print("\n ¬°BOOOM! Has encontrado una mina. üî•‚ò†Ô∏è")
            return False  # Fin del juego
        else:
            print("\n No hay mina. Puedes seguir jugando. üëÄüëå")
            mostrar_tablero_actualizado(matriz, fila, columna)
            return True  # Continuar jugando
```

Al final se imprime la interfaz y se llaman las funciones

```
print("------------------------------------------")
print("--BIENVENIDO AL  BUSCAMINAS STRAVAGANTE--")
print("------------------------------------------")
tamano = int(input("--Tama√±o del tablero: "))  # Pedimos al usuario el tama√±o y la cantidad de minas
minas = int(input("--Cantidad de minas: "))
print("------------------------------------------")

# Generamos el tablero y mostramos el resultado
matriz = generar_tablero(tamano, minas)
tablerito(tamano, matriz)
print("Las minas colocadas son =", minas)
```

Este bucle hace que el proceso se repita hasta que el jugador ingrese una mina=

```
# Bucle principal del juego
while True:
    if verificar_coordenada(matriz) == False:
        break  # Fin del juego si se encuentra una mina
```


**Nota:**Esto es solo un avance del proyecto, este se encuentra anexado al principio del repositorio




